defmodule Exdn do
  @moduledoc """
    Exdn is a two-way translator between Elixir data structures and data
    following the [edn specification](https://github.com/edn-format/edn);
    it wraps the [erldn edn parser](https://github.com/marianoguerra/erldn)
    for Erlang, with some changes in the data formats.

    ## Examples

        iex> Exdn.to_elixir! "[1 :foo]"
        [1, :foo]

        iex> Exdn.to_elixir "{1 :foo, 2 :bar}"
        {:ok, %{1 => :foo, 2 => :bar}}

        iex> Exdn.from_elixir! %{1 => :foo, 2 => :bar}
        "{1 :foo 2 :bar}"

        iex> Exdn.from_elixir %{:foo => {:char, ?a}, {:char, ?b} => {:tag, :inst, "1985-04-12T23:20:50.52Z"} }
        {:ok, "{:foo \\a \\b #inst \"1985-04-12T23:20:50.52Z\"}" }

    ## Type mappings:

      edn	              | Elixir generated by `to_elixir` functions
      ---------------   | -----------------------------------------
      integer	          | integer
      float	            | float
      boolean	          | boolean
      nil	              | nil (atom)
      char              | string
      string	          | string
      list	            | tagged list `{:list, [...]}`
      vector	          | list
      map	              | map
      set	              | mapset
      symbol	          | tagged atom `{:symbol, atom}`
      tagged elements	  | call registered handler for that tag, fail if not found

      Elixir accepted by `from_elixir` functions              | edn
      -----------------------------------------------------   | ---------------
      integer                                                 | integer
      float                                                   | float
      boolean                                                 | boolean
      nil (atom)                                              | nil
      tagged integer `{:char, <integer>}`                     | char
      string                                                  | string
      tagged list `{:list, [...]}`                            | list
      list                                                    | vector
      map                                                     | map
      mapset                                                  | set
      tagged atom `{:symbol, atom}`                           | symbol
      tagged tuple with tag and value `{:tag, Symbol, Value}` | tagged elements
    """

  @doc """
     parses an edn string into an Elixir data structure; this is not a reversible
     conversion as chars are converted to strings, and tagged expressions are
     interpreted. This function can throw exceptions; for example, if a tagged
     expression cannot be interpreted.

     The second (optional) argument allows you to supply your own handlers for
     the interpretation of tagged expressions. These should be in the form of a
     keyword list. The first element of each pair should be a keyword corresponding
     to the tag, and the second element a function of three parameters
     (tag, value, handlers) that handles the tagged values.

     The one-argument version provides default handlers for #inst and #uuid.

## Examples:
      iex> Exdn.to_elixir! "41.2"
      41.2

      iex> Exdn.to_elixir! ":foo"
      :foo

      iex> Exdn.to_elixir! "true"
      true

      iex> Exdn.to_elixir! "nil"
      nil

      iex> Exdn.to_elixir! "\"asd\""
      "asd"

      # Char
      iex> Exdn.to_elixir! "\\a"
      "a"

      # Symbol
      iex> Exdn.to_elixir! "foo"
      {:symbol, :foo}

      # edn vectors become Elixir lists:
      iex> Exdn.to_elixir! "[1 :foo]"
      [1, :foo]

      # edn lists are always tagged. Since Datomic is a principal use of edn, and since lists are
      # used in Datomic primarily for executable expressions rather than as data structures, we
      # use Elixir lists to represent vectors and keep edn lists specially tagged:
      iex> Exdn.to_elixir! "(1, :foo)"
      {:list, [1, :foo]}

      # edn sets become Elixir sets:
      iex> Exdn.to_elixir! "\#{1 \\a 1}"
      #MapSet<[1, "a"]>

      # Maps become Elixir maps:
      iex> Exdn.to_elixir! "{1 :foo, 2 :bar}"
      %{1 => :foo, 2 => :bar}

      # Tagged expressions are converted. Standard converters for #inst and #uuid are included:
      iex> Exdn.to_elixir! "#inst \"1985-04-12T23:20:50.52Z\""
      %Calendar.DateTime{abbr: "UTC", day: 12, hour: 23, min: 20, month: 4, sec: 50,
        std_off: 0, timezone: "Etc/UTC", usec: 520000, utc_off: 0, year: 1985}

      iex> Exdn.to_elixir! "#uuid \"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\""
      "f81d4fae-7dec-11d0-a765-00a0c91e6bf6"

      # You can provide your own handlers for tagged expressions:
      iex> handler = fn(_tag, val, _handlers) -> val <> "-converted" end
      iex> Exdn.to_elixir! "#foo \"blarg\"", [{:foo, handler}]
      "blarg-converted"
  """
  def to_elixir!(edn, handlers \\ standard_handlers) do
    erlang_str = edn |> to_char_list
    {:ok, erlang_intermediate } = :erldn.parse_str(erlang_str)
    elrldn_to_elixir!(erlang_intermediate, handlers)
  end

  @doc """
   parses an edn string into an Elixir data structure, but does not throw
   exceptions. The parse result is returned as the second element of a pair
   whose first element is `:ok` -- if there is an error the first element will
   be `:error` and the second the error that was raised.

## Examples:

     iex> Exdn.to_elixir "{1 :foo, 2 :bar}"
     {:ok, %{1 => :foo, 2 => :bar}}

     iex> Exdn.to_elixir "{:foo, \\a, \\b #foo \"blarg\" }"
     {:error, %RuntimeError{:message => "Handler not found for tag foo with tagged expression blarg"}}
  """
  def to_elixir(val, handlers \\ standard_handlers) do
    try do
      {:ok, to_elixir!(val, handlers)}
    rescue
      e -> {:error, e}
    end
  end

  defp elrldn_to_elixir!( {:char, char},   _handlers ), do: to_string([char])
  defp elrldn_to_elixir!( {:keyword, nil}, _handlers ), do: nil

  defp elrldn_to_elixir!( {:tag, tag, val}, handlers )  do
    evaluate_tagged_expr({:tag, tag, val}, handlers)
  end

  defp elrldn_to_elixir!( {:vector, items}, handlers )  do
    Enum.map(items, fn(item) -> elrldn_to_elixir!(item, handlers) end)
  end

  defp elrldn_to_elixir!( {:set, items},    handlers )  do
    convert_set(items, fn(x) -> elrldn_to_elixir!(x, handlers) end)
  end

  defp elrldn_to_elixir!( {:map, pairs},    handlers )  do
    convert_map(pairs, fn(x) -> elrldn_to_elixir!(x, handlers) end)
  end

  defp elrldn_to_elixir!( items,            handlers) when is_list(items) do
    {:list, Enum.map(items, fn(item) -> elrldn_to_elixir!(item, handlers) end)}
  end

  defp elrldn_to_elixir!(val, _handlers), do: val

  @doc """
    parses an edn string into an Elixir data structure, but in a reversible way --
    chars and tagged expressions are represented using tuples whose first element
    is `:char` or `:tag`, respectively.

## Examples:
      iex> Exdn.to_reversible( "\\a" )
      {:char, ?a}

      iex> Exdn.to_reversible "#inst \"1985-04-12T23:20:50.52Z\""
      {:tag, :inst, "1985-04-12T23:20:50.52Z"}

      # An unknown tag raises no error when using the reversible conversion:
      iex> Exdn.to_reversible "#foo \"blarg\""
      {:tag, :foo, "blarg"}
  """
  def to_reversible(edn) do
    erlang_str = edn |> to_char_list
    {:ok, erlang_intermediate } = :erldn.parse_str(erlang_str)
    reversible(erlang_intermediate)
  end

  defp reversible({:char, char}), do: {:char, char}
  defp reversible({:keyword, nil}), do: nil
  defp reversible({:tag, tag, val}), do: {:tag, tag, val}
  defp reversible({:vector, items}), do: Enum.map(items, fn(item) -> reversible(item) end)
  defp reversible({:set, items}), do: convert_set(items, fn(x) -> reversible(x) end)
  defp reversible({:map, pairs}), do: convert_map(pairs, fn(x) -> reversible(x) end)
  defp reversible(items) when is_list(items), do: {:list, Enum.map(items, fn(item) -> reversible(item) end)}
  defp reversible(val), do: val

  defp convert_map(pairs, converter) do
    convert_pair = fn({key, val}) -> { converter.(key), converter.(val) } end
    pairs |> Enum.map(convert_pair) |> Map.new
  end

  defp convert_set(items, converter) do
    convert_item = fn (item) -> converter.(item) end
    items |> Enum.map(convert_item) |> MapSet.new
  end

  @doc """
    converts an Elixir data structure in the "reversible" format (see below) into
    an edn string. Will raise exceptions if the data structure cannot be converted.

## Examples:

      # The intermediate representation can be converted back to edn:

      iex> Exdn.from_elixir! 41.2
      "41.2"

      iex> Exdn.from_elixir! :foo
      ":foo"

      iex> Exdn.from_elixir! true
      "true"

      iex> Exdn.from_elixir! nil
      "nil"

      iex> Exdn.from_elixir! "asd"
      "\"asd\""

      iex> Exdn.from_elixir! {:char, ?a}
      "\\a"

      iex> Exdn.from_elixir! {:symbol, :foo}
      "foo"

      iex> Exdn.from_elixir! [1, :foo]
      "[1 :foo]"

      iex> Exdn.from_elixir! {:list, [1, :foo]}
      "(1 :foo)"

      iex> Exdn.from_elixir! MapSet.new([1, :foo])
      "\#{1 :foo}"

      iex> Exdn.from_elixir! %{1 => :foo, 2 => :bar}
      "{1 :foo 2 :bar}"

      iex> Exdn.from_elixir! {:tag, :inst, "1985-04-12T23:20:50.52Z"}
      "#inst \"1985-04-12T23:20:50.52Z\""
  """
  def from_elixir!(elixir_data) do
    erldn_intermediate = to_erldn_intermediate(elixir_data)
    :erldn.to_string(erldn_intermediate) |> to_string
  end

  @doc """
    safe version of `from_elixir!/1` -- the edn string is returned as the second
    element of a pair whose first element is `:ok` -- if there is an error the first
    element will be `:error` and the second the error that was raised.

## Example:

      iex> Exdn.from_elixir %{:foo => {:char, ?a}, {:char, ?b} => {:tag, :inst, "1985-04-12T23:20:50.52Z"} }
      {:ok, "{:foo \\a \\b #inst \"1985-04-12T23:20:50.52Z\"}" }
  """
  def from_elixir(elixir_data) do
    try do
      {:ok, from_elixir!(elixir_data)}
    rescue
      e -> {:error, e}
    end
  end

  defp to_erldn_intermediate(items) when is_list(items) do
    {:vector, Enum.map(items, fn(x) -> to_erldn_intermediate(x) end)}
  end

  defp to_erldn_intermediate( {:list, items} )  do
    Enum.map(items, fn(x) -> to_erldn_intermediate(x) end)
  end

  defp to_erldn_intermediate(%MapSet{} = set) do
    items = Enum.map(set, fn(x) -> to_erldn_intermediate(x) end)
    {:set, items}
  end

  defp to_erldn_intermediate(pairs) when is_map(pairs) do
    convert_pair = fn({key, val}) -> { to_erldn_intermediate(key), to_erldn_intermediate(val) } end
    keyword_list = pairs |> Enum.map(convert_pair)
    {:map, keyword_list}
  end

  defp to_erldn_intermediate( {:tag, tag, val} ), do: {:tag, tag, to_erldn_intermediate(val) }

  defp to_erldn_intermediate(val), do: val

  @doc """
    extracts a list from the tagged reversible representation; does not operate at all
    on the contents of the extracted list.

## Example:

      iex> Exdn.tagged_list_to_list {:list, [:foo]}
      [:foo]
  """
  def tagged_list_to_list({:list, list}), do: list

  @doc """
    extracts a char (as a string) from the tagged reversible representation.

## Example:

      iex> Exdn.tagged_char_to_string {:char, ?a}
      "a"
  """
  def tagged_char_to_string({:char, code}), do: to_string([code])

  @doc """
    interprets a tagged expression using the tagged reversible representation and
    handlers passed in as a keyword list. Does not operate at all
    on the contents of the extracted list.

## Example:

      iex> tagged = {:tag, :foo, "blarg"}
      iex> handler = fn(_tag, val, _handlers) -> val <> "-converted" end
      iex> Exdn.evaluate_tagged_expr(tagged, [{:foo, handler}]
      "blarg-converted"
  """
  def evaluate_tagged_expr({:tag, tag, expr}, handlers) do
    handler = handlers[tag]
    if handler do
      handler.(tag, expr, handlers)
    else
      raise "Handler not found for tag #{tag} with tagged expression #{expr}"
    end
  end

  # Handlers
  defp standard_handlers do
    timestamp_handler = { :inst, fn(_tag, val, _handlers) -> inst_handler(val) end }
    uuid_handler = { :uuid, fn(_tag, val, _handlers) -> val |> to_string end }
    # TODO Discard Handler This shouldn't return nil; it should swallow the val.
    # discard_handler = { :_, fn(tag, val, handlers) -> ??? end }
    [ timestamp_handler, uuid_handler ]
  end

  defp inst_handler(char_list) do
    {:ok, result} = char_list |> to_string |> Calendar.DateTime.Parse.rfc3339_utc
    result
  end
end
